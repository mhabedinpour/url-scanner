// Code generated by MockGen. DO NOT EDIT.
// Source: interface.go
//
// Generated by this command:
//
//	mockgen -package mockstorage -source=interface.go -destination=mock/mockstorage.go *
//

// Package mockstorage is a generated GoMock package.
package mockstorage

import (
	context "context"
	reflect "reflect"
	domain "scanner/pkg/domain"
	storage "scanner/pkg/storage"
	time "time"

	gomock "go.uber.org/mock/gomock"
)

// MockAllStorage is a mock of AllStorage interface.
type MockAllStorage struct {
	ctrl     *gomock.Controller
	recorder *MockAllStorageMockRecorder
	isgomock struct{}
}

// MockAllStorageMockRecorder is the mock recorder for MockAllStorage.
type MockAllStorageMockRecorder struct {
	mock *MockAllStorage
}

// NewMockAllStorage creates a new mock instance.
func NewMockAllStorage(ctrl *gomock.Controller) *MockAllStorage {
	mock := &MockAllStorage{ctrl: ctrl}
	mock.recorder = &MockAllStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAllStorage) EXPECT() *MockAllStorageMockRecorder {
	return m.recorder
}

// DeleteScan mocks base method.
func (m *MockAllStorage) DeleteScan(ctx context.Context, userID domain.UserID, ID domain.ScanID) (*domain.Scan, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteScan", ctx, userID, ID)
	ret0, _ := ret[0].(*domain.Scan)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteScan indicates an expected call of DeleteScan.
func (mr *MockAllStorageMockRecorder) DeleteScan(ctx, userID, ID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteScan", reflect.TypeOf((*MockAllStorage)(nil).DeleteScan), ctx, userID, ID)
}

// ScanByID mocks base method.
func (m *MockAllStorage) ScanByID(ctx context.Context, userID domain.UserID, ID domain.ScanID) (*domain.Scan, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScanByID", ctx, userID, ID)
	ret0, _ := ret[0].(*domain.Scan)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ScanByID indicates an expected call of ScanByID.
func (mr *MockAllStorageMockRecorder) ScanByID(ctx, userID, ID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanByID", reflect.TypeOf((*MockAllStorage)(nil).ScanByID), ctx, userID, ID)
}

// StoreScans mocks base method.
func (m *MockAllStorage) StoreScans(ctx context.Context, scans ...domain.Scan) ([]domain.Scan, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range scans {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StoreScans", varargs...)
	ret0, _ := ret[0].([]domain.Scan)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StoreScans indicates an expected call of StoreScans.
func (mr *MockAllStorageMockRecorder) StoreScans(ctx any, scans ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, scans...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreScans", reflect.TypeOf((*MockAllStorage)(nil).StoreScans), varargs...)
}

// UpdatePendingScansByURL mocks base method.
func (m *MockAllStorage) UpdatePendingScansByURL(ctx context.Context, URL string, updates storage.ScanUpdates) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdatePendingScansByURL", ctx, URL, updates)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdatePendingScansByURL indicates an expected call of UpdatePendingScansByURL.
func (mr *MockAllStorageMockRecorder) UpdatePendingScansByURL(ctx, URL, updates any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatePendingScansByURL", reflect.TypeOf((*MockAllStorage)(nil).UpdatePendingScansByURL), ctx, URL, updates)
}

// UserScans mocks base method.
func (m *MockAllStorage) UserScans(ctx context.Context, userID domain.UserID, cursor time.Time, limit uint) (storage.UserScans, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UserScans", ctx, userID, cursor, limit)
	ret0, _ := ret[0].(storage.UserScans)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UserScans indicates an expected call of UserScans.
func (mr *MockAllStorageMockRecorder) UserScans(ctx, userID, cursor, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserScans", reflect.TypeOf((*MockAllStorage)(nil).UserScans), ctx, userID, cursor, limit)
}

// MockTxStorage is a mock of TxStorage interface.
type MockTxStorage struct {
	ctrl     *gomock.Controller
	recorder *MockTxStorageMockRecorder
	isgomock struct{}
}

// MockTxStorageMockRecorder is the mock recorder for MockTxStorage.
type MockTxStorageMockRecorder struct {
	mock *MockTxStorage
}

// NewMockTxStorage creates a new mock instance.
func NewMockTxStorage(ctrl *gomock.Controller) *MockTxStorage {
	mock := &MockTxStorage{ctrl: ctrl}
	mock.recorder = &MockTxStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxStorage) EXPECT() *MockTxStorageMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockTxStorage) Commit() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockTxStorageMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockTxStorage)(nil).Commit))
}

// DeleteScan mocks base method.
func (m *MockTxStorage) DeleteScan(ctx context.Context, userID domain.UserID, ID domain.ScanID) (*domain.Scan, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteScan", ctx, userID, ID)
	ret0, _ := ret[0].(*domain.Scan)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteScan indicates an expected call of DeleteScan.
func (mr *MockTxStorageMockRecorder) DeleteScan(ctx, userID, ID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteScan", reflect.TypeOf((*MockTxStorage)(nil).DeleteScan), ctx, userID, ID)
}

// Rollback mocks base method.
func (m *MockTxStorage) Rollback() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback")
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockTxStorageMockRecorder) Rollback() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockTxStorage)(nil).Rollback))
}

// ScanByID mocks base method.
func (m *MockTxStorage) ScanByID(ctx context.Context, userID domain.UserID, ID domain.ScanID) (*domain.Scan, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScanByID", ctx, userID, ID)
	ret0, _ := ret[0].(*domain.Scan)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ScanByID indicates an expected call of ScanByID.
func (mr *MockTxStorageMockRecorder) ScanByID(ctx, userID, ID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanByID", reflect.TypeOf((*MockTxStorage)(nil).ScanByID), ctx, userID, ID)
}

// StoreScans mocks base method.
func (m *MockTxStorage) StoreScans(ctx context.Context, scans ...domain.Scan) ([]domain.Scan, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range scans {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StoreScans", varargs...)
	ret0, _ := ret[0].([]domain.Scan)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StoreScans indicates an expected call of StoreScans.
func (mr *MockTxStorageMockRecorder) StoreScans(ctx any, scans ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, scans...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreScans", reflect.TypeOf((*MockTxStorage)(nil).StoreScans), varargs...)
}

// UpdatePendingScansByURL mocks base method.
func (m *MockTxStorage) UpdatePendingScansByURL(ctx context.Context, URL string, updates storage.ScanUpdates) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdatePendingScansByURL", ctx, URL, updates)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdatePendingScansByURL indicates an expected call of UpdatePendingScansByURL.
func (mr *MockTxStorageMockRecorder) UpdatePendingScansByURL(ctx, URL, updates any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatePendingScansByURL", reflect.TypeOf((*MockTxStorage)(nil).UpdatePendingScansByURL), ctx, URL, updates)
}

// UserScans mocks base method.
func (m *MockTxStorage) UserScans(ctx context.Context, userID domain.UserID, cursor time.Time, limit uint) (storage.UserScans, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UserScans", ctx, userID, cursor, limit)
	ret0, _ := ret[0].(storage.UserScans)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UserScans indicates an expected call of UserScans.
func (mr *MockTxStorageMockRecorder) UserScans(ctx, userID, cursor, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserScans", reflect.TypeOf((*MockTxStorage)(nil).UserScans), ctx, userID, cursor, limit)
}

// MockStorage is a mock of Storage interface.
type MockStorage struct {
	ctrl     *gomock.Controller
	recorder *MockStorageMockRecorder
	isgomock struct{}
}

// MockStorageMockRecorder is the mock recorder for MockStorage.
type MockStorageMockRecorder struct {
	mock *MockStorage
}

// NewMockStorage creates a new mock instance.
func NewMockStorage(ctrl *gomock.Controller) *MockStorage {
	mock := &MockStorage{ctrl: ctrl}
	mock.recorder = &MockStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStorage) EXPECT() *MockStorageMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockStorage) Begin(ctx context.Context) (storage.TxStorage, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin", ctx)
	ret0, _ := ret[0].(storage.TxStorage)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockStorageMockRecorder) Begin(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockStorage)(nil).Begin), ctx)
}

// Close mocks base method.
func (m *MockStorage) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockStorageMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockStorage)(nil).Close))
}

// DeleteScan mocks base method.
func (m *MockStorage) DeleteScan(ctx context.Context, userID domain.UserID, ID domain.ScanID) (*domain.Scan, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteScan", ctx, userID, ID)
	ret0, _ := ret[0].(*domain.Scan)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteScan indicates an expected call of DeleteScan.
func (mr *MockStorageMockRecorder) DeleteScan(ctx, userID, ID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteScan", reflect.TypeOf((*MockStorage)(nil).DeleteScan), ctx, userID, ID)
}

// ScanByID mocks base method.
func (m *MockStorage) ScanByID(ctx context.Context, userID domain.UserID, ID domain.ScanID) (*domain.Scan, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScanByID", ctx, userID, ID)
	ret0, _ := ret[0].(*domain.Scan)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ScanByID indicates an expected call of ScanByID.
func (mr *MockStorageMockRecorder) ScanByID(ctx, userID, ID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanByID", reflect.TypeOf((*MockStorage)(nil).ScanByID), ctx, userID, ID)
}

// StoreScans mocks base method.
func (m *MockStorage) StoreScans(ctx context.Context, scans ...domain.Scan) ([]domain.Scan, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range scans {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StoreScans", varargs...)
	ret0, _ := ret[0].([]domain.Scan)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StoreScans indicates an expected call of StoreScans.
func (mr *MockStorageMockRecorder) StoreScans(ctx any, scans ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, scans...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreScans", reflect.TypeOf((*MockStorage)(nil).StoreScans), varargs...)
}

// UpdatePendingScansByURL mocks base method.
func (m *MockStorage) UpdatePendingScansByURL(ctx context.Context, URL string, updates storage.ScanUpdates) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdatePendingScansByURL", ctx, URL, updates)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdatePendingScansByURL indicates an expected call of UpdatePendingScansByURL.
func (mr *MockStorageMockRecorder) UpdatePendingScansByURL(ctx, URL, updates any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatePendingScansByURL", reflect.TypeOf((*MockStorage)(nil).UpdatePendingScansByURL), ctx, URL, updates)
}

// UserScans mocks base method.
func (m *MockStorage) UserScans(ctx context.Context, userID domain.UserID, cursor time.Time, limit uint) (storage.UserScans, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UserScans", ctx, userID, cursor, limit)
	ret0, _ := ret[0].(storage.UserScans)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UserScans indicates an expected call of UserScans.
func (mr *MockStorageMockRecorder) UserScans(ctx, userID, cursor, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserScans", reflect.TypeOf((*MockStorage)(nil).UserScans), ctx, userID, cursor, limit)
}

// WithTx mocks base method.
func (m *MockStorage) WithTx(ctx context.Context, cb func(storage.AllStorage) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithTx", ctx, cb)
	ret0, _ := ret[0].(error)
	return ret0
}

// WithTx indicates an expected call of WithTx.
func (mr *MockStorageMockRecorder) WithTx(ctx, cb any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithTx", reflect.TypeOf((*MockStorage)(nil).WithTx), ctx, cb)
}
